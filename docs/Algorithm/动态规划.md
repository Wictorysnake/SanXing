# 算法篇-动态规划

## 定义

动态规划（Dynamic Programming）是运筹学的一个分支，是求解决策过程（decision process）最优化的数学方法。20 世纪 50 年代初美国数学家 R.E.Bellman 等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。（生成自`Copilot`）

## 方法

1. 将大问题分解为若干个子问题；
2. 得到状态转移方程（这个是重中之重）；
3. 确定初始条件。

### 举个栗子

[leetcode-70.爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)

题目描述：

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

穷举法：

```js
假设楼梯有 5 阶，那么爬楼梯的方法有：

1. 1 阶 + 1 阶 + 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 1 阶 + 1 阶 + 2 阶
3. 1 阶 + 1 阶 + 2 阶 + 1 阶
4. 1 阶 + 2 阶 + 1 阶 + 1 阶
5. 2 阶 + 1 阶 + 1 阶 + 1 阶
6. 1 阶 + 2 阶 + 2 阶
7. 2 阶 + 1 阶 + 2 阶
8. 2 阶 + 2 阶 + 1 阶

已知我们每次可以爬 1 或 2 个台阶，那么问题分解为：最后一步爬 1 阶和最后一步爬 2 阶的情况。又因为总共有 5 阶，那么问题又转化为爬 4 阶 和爬 3 阶共有多少种方法，以此类推，直到爬 1 阶和爬 2 阶。
```

状态转移方程：

```js
dp[n] = dp[n - 1] + dp[n - 2]
```

初始条件：

```js
dp[1] = 1
dp[2] = 2
```

代码实现：

```js
function climbStairs(n) {
  if (n === 1) return 1
  if (n === 2) return 2
  const dp = []
  dp[1] = 1
  dp[2] = 2
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
}
```

## 总结

动态规划适用于能把大问题拆分成小问题，并且这些小问题又是相互关联的，最后得到状态转移方程，从而解决问题。动态规划的难点也就是如何得到状态转移方程，这个需要多练习，多总结。一般的思路是，先找到最后一步，然后找到倒数第二步，以此类推，直到找到初始条件。在没有具体思路的时候，不仿先用穷举法解决，然后再找到状态转移方程，最后再优化代码。
